# -*- coding: utf-8 -*-
"""Main_Ear_Biometrics_Model

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PCBuKe1_TwWYEk2RzJMililcq5ERdrlW

## Using Canny
"""

import cv2
from google.colab.patches import cv2_imshow
import numpy as np
from scipy.ndimage import label

# Load the image
img = cv2.imread('Tarun_22.png')

# Convert the image to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply edge detection using Canny algorithm before filtering apply
edges_b = cv2.Canny(gray, 100, 200)

# Display the original and median filtered images side by side
median_img = cv2.medianBlur(gray, 7)

# Apply edge detection using Canny algorithm after filtering apply
edges = cv2.Canny(median_img, 100, 200)

# Threshold image to create binary image
thresh = 128
binary_img = np.where(img > thresh, 1, 0)

# Find connected components in binary image
labels, num_components = label(binary_img)

# Print number of components
print(f"Number of connected components: {num_components}")

# Find the contours in the image
contours, hierarchy = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Sort the contours by area in descending order
contours = sorted(contours, key=cv2.contourArea, reverse=True)

# Draw the largest contour on a new image
largest_contour_img = cv2.drawContours(np.zeros_like(edges), [contours[0]], 0, (255, 255, 255), -1)

# Display the result
cv2_imshow(img)
cv2_imshow(gray)
cv2_imshow(median_img)
cv2_imshow(edges_b)
cv2_imshow(edges)
cv2_imshow(largest_contour_img)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""# Fit Ellipse and find the Center"""

#  Fit Ellipse in the Contuer image
max_contour = contours[0]
ellipse = cv2.fitEllipse(max_contour)
cv2.ellipse(largest_contour_img, ellipse, (255, 255, 255), 2)
cv2_imshow(largest_contour_img)

# Get the center point of the ellipse and draw a red dot on it
center = tuple(map(int, ellipse[0]))
cv2.circle(largest_contour_img, center, 3, (255, 255, 255), -1)
cv2_imshow(largest_contour_img)

cv2.waitKey(0)
cv2.destroyAllWindows()

"""# 100 Stronges Feature point"""

import cv2
from google.colab.patches import cv2_imshow
import numpy as np
from scipy.ndimage import label

# Load the image
image_name = "Varkha_41.png"
img = cv2.imread(image_name)

# Convert the image to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply edge detection using Canny algorithm before filtering apply
edges_b = cv2.Canny(gray, 100, 200)

# Display the original and median filtered images side by side
median_img = cv2.medianBlur(gray, 7)

# Apply edge detection using Canny algorithm after filtering apply
edges = cv2.Canny(median_img, 100, 200)

# Threshold image to create binary image
thresh = 128
binary_img = np.where(img > thresh, 1, 0)

# Find connected components in binary image
labels, num_components = label(binary_img)

# Print number of components
print(f"Number of connected components: {num_components}")

# Find the contours in the image
contours, hierarchy = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Sort the contours by area in descending order
contours = sorted(contours, key=cv2.contourArea, reverse=True)

# Draw the largest contour on a new image
largest_contour_img = cv2.drawContours(np.zeros_like(edges), [contours[0]], 0, (255, 255, 255), -1)

# Display the result
cv2_imshow(img)
cv2_imshow(gray)
cv2_imshow(median_img)
cv2_imshow(edges_b)
cv2_imshow(edges)
cv2_imshow(largest_contour_img)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
import csv


# Find the strongest 100 feature points on the contour
corners = cv2.goodFeaturesToTrack(largest_contour_img, 100, 0.01, 1)
corners = corners.reshape(-1, 2)

# Sort the feature points by strength
strengths = gray[corners[:, 1].astype(int), corners[:, 0].astype(int)]
sorted_indices = np.argsort(strengths)[::-1]
strongest_corners = corners[sorted_indices[:100]]

# Draw the feature points as dots on the image
for corner in strongest_corners:
    cv2.circle(largest_contour_img, tuple(corner.astype(int)), 1, (255, 255, 255), -1)

# Display the image with the feature points
cv2_imshow(largest_contour_img)


height, width = largest_contour_img.shape[:2]
center_x, center_y = width // 2, height // 2
cv2.circle(largest_contour_img, (center_x, center_y), 2, (255, 0, 0), -1)

cv2_imshow(largest_contour_img)

# Loop through the 100 strongest feature points
for corner in strongest_corners:
    # Draw a line from the center point to the feature point
    cv2.line(largest_contour_img, (center_x, center_y), tuple(corner.astype(int)), (255, 255, 255), 1)

# Display the image with the lines and feature points
cv2_imshow(largest_contour_img)


distances = []
for corner in strongest_corners:
    x, y = corner.astype(int)
    dist = np.sqrt((x - center_x)**2 + (y - center_y)**2)
    distances.append(dist)

print("Distances between center point and strongest feature points:")
for i, dist in enumerate(distances):
    print(f"Feature point {i+1}: {dist:.2f} pixels away from center point")
    # Store the distances in a CSV file

cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
import csv

# Find the strongest 100 feature points on the contour
corners = cv2.goodFeaturesToTrack(largest_contour_img, 200, 0.01, 1)
corners = corners.reshape(-1, 2)

# Sort the feature points by strength
strengths = gray[corners[:, 1].astype(int), corners[:, 0].astype(int)]
sorted_indices = np.argsort(strengths)[::-1]
strongest_corners = corners[sorted_indices[:100]]

# Draw the feature points as dots on the image
for corner in strongest_corners:
    cv2.circle(largest_contour_img, tuple(corner.astype(int)), 1, (255, 255, 255), -1)

# Display the image with the feature points
cv2_imshow(largest_contour_img)


height, width = largest_contour_img.shape[:2]
center_x, center_y = width // 2, height // 2
cv2.circle(largest_contour_img, (center_x, center_y), 2, (255, 0, 0), -1)

cv2_imshow(largest_contour_img)

# Loop through the 100 strongest feature points
for corner in strongest_corners:
    # Draw a line from the center point to the feature point
    cv2.line(largest_contour_img, (center_x, center_y), tuple(corner.astype(int)), (255, 255, 255), 1)

# Display the image with the lines and feature points
cv2_imshow(largest_contour_img)


distances = []
for corner in strongest_corners:
    x, y = corner.astype(int)
    dist = np.sqrt((x - center_x)**2 + (y - center_y)**2)
    distances.append(dist)

print("Distances between center point and strongest feature points:")
for i, dist in enumerate(distances):
    print(f"Feature point {i+1}: {dist:.2f} pixels away from center point")

# Store the distances in a CSV file
with open("Varkha_Distance_41.csv", mode="w", newline='') as file:
    writer = csv.writer(file)
    writer.writerow(["Image File Name", "Feature Point", "Distance from Center"])
    for i, dist in enumerate(distances):
        writer.writerow([image_name, f"{i+1}", f"{dist:.2f}"])

cv2.waitKey(0)
cv2.destroyAllWindows()

"""## Hole Filling """

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# img = cv2.imread('Tarun_25.png')
image_name = "Labhesh_41.png"
img = cv2.imread(image_name)

# Convert the image to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply edge detection using Canny algorithm before filtering apply
edges_b = cv2.Canny(gray, 100, 200)

# Display the original and median filtered images side by side
median_img = cv2.medianBlur(gray, 9)

# Apply edge detection using Canny algorithm after filtering apply
edges = cv2.Canny(median_img, 150, 250)



# Hole fill 
# Define a kernel for the closing operation
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
# Perform the closing operation to fill holes
img_closed = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)




# Find the contours in the image
contours, hierarchy = cv2.findContours(img_closed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Sort the contours by area in descending order
contours = sorted(contours, key=cv2.contourArea, reverse=True)

# Draw the largest contour on a new image
largest_contour_img = cv2.drawContours(np.zeros_like(img_closed), [contours[0]], 0, (255, 255, 255), -1)

# Display the results
cv2_imshow(img)
# cv2_imshow(img_filtered)
cv2_imshow(edges_b)
cv2_imshow(edges)
cv2_imshow(largest_contour_img)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
import csv


# Find the strongest 100 feature points on the contour
corners = cv2.goodFeaturesToTrack(largest_contour_img, 100, 0.01, 1)
corners = corners.reshape(-1, 2)

# Sort the feature points by strength
strengths = gray[corners[:, 1].astype(int), corners[:, 0].astype(int)]
sorted_indices = np.argsort(strengths)[::-1]
strongest_corners = corners[sorted_indices[:100]]

# Draw the feature points as dots on the image
for corner in strongest_corners:
    cv2.circle(largest_contour_img, tuple(corner.astype(int)), 1, (255, 255, 255), -1)

# Display the image with the feature points
cv2_imshow(largest_contour_img)


height, width = largest_contour_img.shape[:2]
center_x, center_y = width // 2, height // 2
cv2.circle(largest_contour_img, (center_x, center_y), 2, (255, 0, 0), -1)

cv2_imshow(largest_contour_img)

# Loop through the 100 strongest feature points
for corner in strongest_corners:
    # Draw a line from the center point to the feature point
    cv2.line(largest_contour_img, (center_x, center_y), tuple(corner.astype(int)), (255, 255, 255), 1)

# Display the image with the lines and feature points
cv2_imshow(largest_contour_img)


distances = []
for corner in strongest_corners:
    x, y = corner.astype(int)
    dist = np.sqrt((x - center_x)**2 + (y - center_y)**2)
    distances.append(dist)

print("Distances between center point and strongest feature points:")
for i, dist in enumerate(distances):
    print(f"Feature point {i+1}: {dist:.2f} pixels away from center point")
    # Store the distances in a CSV file

cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
import csv

# Find the strongest 100 feature points on the contour
corners = cv2.goodFeaturesToTrack(largest_contour_img, 200, 0.01, 1)
corners = corners.reshape(-1, 2)

# Sort the feature points by strength
strengths = gray[corners[:, 1].astype(int), corners[:, 0].astype(int)]
sorted_indices = np.argsort(strengths)[::-1]
strongest_corners = corners[sorted_indices[:100]]

# Draw the feature points as dots on the image
for corner in strongest_corners:
    cv2.circle(largest_contour_img, tuple(corner.astype(int)), 1, (255, 255, 255), -1)

# Display the image with the feature points
cv2_imshow(largest_contour_img)


height, width = largest_contour_img.shape[:2]
center_x, center_y = width // 2, height // 2
cv2.circle(largest_contour_img, (center_x, center_y), 2, (255, 0, 0), -1)

cv2_imshow(largest_contour_img)

# Loop through the 100 strongest feature points
for corner in strongest_corners:
    # Draw a line from the center point to the feature point
    cv2.line(largest_contour_img, (center_x, center_y), tuple(corner.astype(int)), (255, 255, 255), 1)

# Display the image with the lines and feature points
cv2_imshow(largest_contour_img)


distances = []
for corner in strongest_corners:
    x, y = corner.astype(int)
    dist = np.sqrt((x - center_x)**2 + (y - center_y)**2)
    distances.append(dist)

print("Distances between center point and strongest feature points:")
for i, dist in enumerate(distances):
    print(f"Feature point {i+1}: {dist:.2f} pixels away from center point")

# Store the distances in a CSV file
with open("Labhesh_Distance_41.csv", mode="w", newline='') as file:
    writer = csv.writer(file)
    writer.writerow(["Image File Name", "Feature Point", "Distance from Center"])
    for i, dist in enumerate(distances):
        writer.writerow([image_name, f"{i+1}", f"{dist:.2f}"])

cv2.waitKey(0)
cv2.destroyAllWindows()

"""## Ellipse fitting on the Original Image"""

# import cv2

# # img = cv2.imread('resize-16782922871249110622pic.jpg')
# # gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# # ret, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV+cv2.THRESH_OTSU)

# # contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# # contours = sorted(contours, key=cv2.contourArea, reverse=True)
# max_contour = contours[0]

# ellipse = cv2.fitEllipse(max_contour)

# cv2.ellipse(img, ellipse, (255, 255, 255), 2)

# cv2_imshow(img)
# cv2.waitKey(0)

"""## 100 Stronges Feature point on Image"""

# import cv2
# import numpy as np

# # Load image
# img = cv2.imread('Hitesh_0.png')

# # Convert image to grayscale
# gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# # Find center of image
# height, width = gray.shape
# center_x, center_y = width // 2, height // 2

# # Set up feature detector
# sift = cv2.xfeatures2d.SIFT_create()

# # Detect keypoints and compute descriptors
# keypoints, descriptors = sift.detectAndCompute(gray, None)

# # Calculate distances from center to each keypoint
# distances = np.sqrt((center_x - np.array([kp.pt[0] for kp in keypoints])) ** 2 +
#                     (center_y - np.array([kp.pt[1] for kp in keypoints])) ** 2)

# # Sort keypoints by distance from center
# sorted_indices = np.argsort(distances)

# # Get strongest 100 keypoints
# strongest_indices = sorted_indices[:100]
# strongest_keypoints = [keypoints[i] for i in strongest_indices]

# # Draw keypoints on image
# img_with_keypoints = cv2.drawKeypoints(gray, strongest_keypoints, None)

# # Display image with keypoints
# cv2_imshow(img_with_keypoints)
# cv2.waitKey(0)
# cv2.destroyAllWindows()

